{
  "head": {
    "title": "Exploring The Soil Moisture Dataset From Auto Farm",
    "subtitle": "Wrangling soil moisture data into an explorable form.",
    "date": 1609111108,
    "link": "auto-farm-machine-learning-pandas-matplotlib-capacitive-soil-moisture",
    "description": "The soil moisture from the plants in AutoFarm were captured using cheap capacitive sensors. Explore how to wrangle this data into an explorable manner.",
    "image": "image/autofarm/soil_sensor.jpg",
    "markdown": true,
    "tags": [
      "programming",
      "python",
      "postgres",
      "opencv",
      "sklearn",
      "keras",
      "regression",
      "tensorflow",
      "neural",
      "network",
      "pandas",
      "numpy",
      "matplotlib"
    ]
  },
  "contents": "<p>Soil moisture is definitely a key data point I want to track when\ngrowing my plants. It allows me to view exactly how fast the moisture\nis evaporating from the soil and tells me when I show probably\nwater the plants again.</p>\n<p>But, without using some intuition, I can't really tell when exactly around what time I will have to water my plants. In order to do that, I would have to apply some machine learning!</p>\n<p>Now then, the soil sensors I am using output a value range of 0 to 1023.\nBut to be honest, I have never seen it dip below 300 nor rise above 600. Not that it really matters though, because in the end if I use the same sensors with the same electronics, the <b>rate of change</b> should be approximatly the same function after the data is <b>normalized</b>. At least, that's what I hope.</p>\n<p>Let's first load and wrangle some of the data and graph it. First, load it.</p>\n<pre><code class=\"python language-python\">import pandas as pd\ndf = pd.read_csv('../full_dataset/soil_full_sensor_one.stripped.csv')\ndf.head()\n</code></pre>\n<p>Looking at the top of the dataframe, here is the form of the data.</p>\n<pre><code>value,timestamp\n400,2020-10-10 07:00:00.607519043\n400,2020-10-10 07:00:00.619821289\n400,2020-10-10 07:00:02.719929199\n402,2020-10-10 07:00:02.734273193\n401,2020-10-10 07:00:04.854030518\n401,2020-10-10 07:00:04.866216797\n402,2020-10-10 07:00:06.973232178\n402,2020-10-10 07:00:06.985046875\n</code></pre>\n<p>Now, we do a bit of wrangling because this dataset is actually 2,081,411 data points!! Each data point is 0.5 seconds apart from one another and there is just absolutely no way we need that much resolution for soil that evaporates over the course of hours. So let's bucket the data into the averages every 60 seconds. That should be really easy with pandas.</p>\n<pre><code class=\"python language-python\">import numpy as np\nfrom dateutil import parser as dateparser\n\n# convert the iso strings to unix milliseconds\ndf.timestamp = [dateparser.isoparse(x) for x in df.timestamp]\ndf.timestamp = df.timestamp.astype(np.int64) / 1E6\n\n# now that it's in milliseconds, we can convert to pandas datetime\ndf.timestamp = pd.to_datetime(df.timestamp, unit='ms')\n\n# using this awesome pandas Grouper, we can easily group the value column into buckets and then aggregate it into the average. Piece of cake.\ndf_group = df.groupby(pd.Grouper(key='timestamp', freq='60s'))['value'].agg('mean')\n\n# Grouper doesn't return a DataFrame. So convert it into one!\ndf_group = df_group.to_frame().reset_index()\n\n# convert the timestamp back into unix millisecond timestamps\ndf_group.timestamp = df_group.timestamp.astype(np.int64) / 1E6\n\n# there might be a few rows that are nan now after the aggregation. So drop them!\ndf_group = df_group.dropna()\n</code></pre>\n<p>Now one important piece of data that we need to load is the times of each watering. During the course of the experiment, I went old school and wrote down the times in which I watered the plants. This helped in the future when I went to split the data into buckets by these times. So let's load that, and then graph the data and the watering times.</p>\n<pre><code class=\"python language-python\">import matplotlib.pyplot as plot\n\ndfw = pd.read_csv('../full_dataset/soil_water_times.csv')\n\nplot.figure(figsize=(20, 4))\nplot.xlabel('Time (unix milliseconds)')\nplot.ylabel('Soil Moisture (Conductivity) Value')\nplot.title('Soil Moisture over Time')\nplot.plot(df_group.timestamp, df_group.value, '.')\nfor time in dfw.timestamp:\n    plot.axvline(x=time, color='red')\nplot.show()\n</code></pre>\n<p><img src=\"http://127.0.0.1:5000/image/autofarm/agged20s_soil_moisture_marked.png\"></p>\n<p>The data looks… not good, depending on your perspective. But to me, the watering times are pretty much spot on, and, each segment looks to have a very similar slope, which is the key to this experiment.</p>\n<p>So let's continue with the code and split the data into buckets by each of the watering times. Which, is incredible easy with the pandas library.</p>\n<pre><code class=\"python language-python\"># get the bins from the dataframe. I sorted them for sanity.\nbins = sorted(dfw.timestamp.values)\n\n# create the bins on a new column in the dataframe. Super easy!\ndf_group['binned'] = pd.cut(df_group.timestamp, bins)\n\n# drop any na data and reset the index just like we did before\ndf_group = df_group.dropna()\ndf_group = df_group.reset_index()\n\n# group the data by the bins and get the indicies of those groups\ndf_groups = df_group.groupby(['binned']).groups\ndf_groups_keys = list(df_groups.keys())\nmarked = []\n\nfor key in df_groups_keys:\n    # get the list of indicies in the group\n    indicies = sorted(df_groups[key])\n\n    # select all the rows from the indicies!\n    frame = df_group.iloc[indicies]\n\n    # drop the binned column and append the dataframe to the list\n    frame = frame.drop(['binned'], axis=1)\n    marked.append(frame)\n</code></pre>\n<p>Sometimes, Python is a pain in the butt. But when you really know how to utilize it, it just makes life so much easier. So let's continue and now plot all the of sections!</p>\n<pre><code class=\"python language-python\">figure, axises = plot.subplots(4, 4, figsize=(15, 10))\naxises = [item for sublist in axises for item in sublist]\nfigure.tight_layout(h_pad=4)\n\nfor index in range(len(marked)):\n    frame = marked[index]\n    axises[index].set_title(f'Index {index}')\n    axises[index].plot(frame.timestamp, frame.value, '.')\nplot.show()\n</code></pre>\n<p><details open>\n<summary>Individual Drops in Moisture from Sensor 1</summary>\n<br>\n    <img src=\"http://127.0.0.1:5000/image/autofarm/soil_agged60s_marked_split.png\">\n</details></p>\n<p>So far, the data is looking kinda janky! At least to the untrained eye. But after we apply some simple linear regression to it, it's actually really linear indeed. So lets do that. The following code is a bit lengthy, but bare with me. </p>\n<pre><code class=\"python language-python\">from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\n\n# declare the figures for the plots\nfigure, axises = plot.subplots(4, 4, figsize=(15, 10))\naxises = [item for sublist in axises for item in sublist]\nfigure.tight_layout(h_pad=4)\n\nfor index in range(len(marked)):\n    frame = marked[index]\n\n    # delete the index column and convert to numpy matrix\n    matrix = np.delete(frame.to_numpy(), 0, 1)\n\n    # scale the entire matrix\n    scaler = StandardScaler().fit(matrix)\n    matrix = scaler.transform(matrix)\n\n    # extract the x and y and reshape to be like [[1], [2], ...]\n    y, x = matrix[:, 0].reshape(-1, 1), matrix[:, 1].reshape(-1, 1)\n\n    # sklearn train test split! easy.\n    x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=42)\n\n    # even easier, fit a linear regression model!\n    model = LinearRegression()\n    model.fit(x_train, y_train)\n\n    # make predictions on the test set\n    y_pred = model.predict(x_test)\n\n    # calculate the mean squared error for the linear predictions\n    error = mean_squared_error(y_test, y_pred)\n\n    # plot the predictions! \n    axises[index].set_title(f'index {index} - error: {round(error, 4)}')\n    axises[index].plot(y_train, x_train, 'b.')\n    axises[index].plot(y_pred, x_test, 'r.')\n\nplot.show()\n</code></pre>\n<p><details open>\n<summary>LinearRegression Applied to Sensor 1</summary>\n<br>\n    <img src=\"http://127.0.0.1:5000/image/autofarm/soil_linear_models.png\">\n</details></p>\n<p>Now, even to the untrained eye, that is very linear in behavior. Which is super excellent indeed. It makes the job of machine learning exceptionally easy. But, we are missing one thing. We normalized the y axis. Which means we lose a lot of the distribution of the time. So lets repeat the code above but remove the standarization part. </p>\n<p>If we plot the slopes, getting the slope using <code>model.coef_[0][0]</code>, we see… something interesting.</p>\n<p><img style=\"max-width: 500px; margin: 0 auto;\" src=\"http://127.0.0.1:5000/image/autofarm/soil_linear_slopes_notnorm.png\"></p>\n<p>The slope is increasing over time. Or, at least, if it's not increasing, it sure isn't the same each time. This could be due to a multitude of reasons. For one, the soil chemistry changes overtime as the plants suck up more nutrients from it. In addition, as the plants grow, you might expect the slope to increase as they will consume more water as they grow. But I think one of the biggest things we fail to gather is <b>light intensity</b>.</p>\n<p>I noticed that day to day, I get different light intensity values at different times of the day. I don't have my plants underneath a grow light. The conditions are subject to the intensity of the light and the cloud coverage given the time. So, in order to real model the behavior of the soil, I would need that extra datapoint.</p>\n<p>Hopefully this was an intuitive approach in understanding how we might model soil moisture consumption over time. This is absolutely not the last time we will look at this dataset are there are plenty of other things we can do to decrease error rates in our models. We could apply a recurrent neural network like an LSTM to have better predictive powers. We can analyze humidity, temperature, and light intensity in a PCA anaylsis to see how they affect the soil moisture. I could also just do a better job at gathering data and making a stable environment for my plants to grow; like recording the water recording times more accurately or doing the experiment over a longer time span.</p>\n<p>In any case, you can guarantee that I will be coming out with full tutorials walking you through all these different techniques and sharing the results with you! Until next time, stay safe. Peace.</p>"
}