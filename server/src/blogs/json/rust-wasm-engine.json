{
  "head": {
    "title": "Rust WASM Physics Engine Test",
    "subtitle": "Rewritting my physics engine in Rust WASM for performance testing",
    "date": 1597636657,
    "link": "rust-wasm-web-assembly-physics-engine-test",
    "description": "Web Assembly is offically a new language of the web joining Javascript, CSS, and HTML. Explore how powerful and fast WASM can be in Rust!",
    "image": "image/generic/web_assembly.png",
    "markdown": true,
    "tags": [
      "rust",
      "web",
      "assembly",
      "javascript",
      "node",
      "programming",
      "algorithm",
      "collision",
      "simulation",
      "math",
      "seperate",
      "axis",
      "theorem",
      "detection",
      "resolution",
      "gravity",
      "momentum",
      "polygon",
      "wasm"
    ]
  },
  "contents": "<p>I've always hated writting any programming language that cannot directly use\npointers, references, threading, or type notation. Python and Javascript? Not my\ncup of tea. Even though I do it for a jobâ€¦ ðŸ™„</p>\n<p>They have always just beenâ€¦ too easy, slow, and difficult to debug. </p>\n<ul>\n<li>To easy as in, I can write the language in my sleep.</li>\n<li>To slow as in, I don't have any control on the level of type notation and references.</li>\n<li>To difficult to debug as in, console.log and print statements everywhere!! ðŸ˜¡</li>\n</ul>\n<p>But, thankfully, WASM came to my rescue. I immediately discovered just how fast this new language\ncould be after I rewrote my <a href=\"https://www.speblog.org/plugin/sat-tester\" rel=\"noopener noreferrer\" target=\"_blank\">Physics Engine</a> into Rust\nWASM.</p>\n<p>The results? I got a <b>20 FPS</b> boost. Yeah. 20 friggen FPS. That's quite a lot.</p>\n<p>So, how did I do it? Well, it's quite easy actually. Whatever programming language you want\nto write WASM in (take your pick: Rust, C, C++, Python, Ruby, Go, and more), you can compile\nyour source code directly into a javascript module importable within your existing javascript\nweb framework.</p>\n<p>In my case, I compiled Rust into WASM, then imported and referenced it in a react app, which itself\nis a micro-frontend. Pretty slick huh?</p>\n<p>There is already great documentation how how you yourself can creat a Rust-WASM project. So I'll just\nprovide you the <a href=\"https://rustwasm.github.io/docs/book/\" rel=\"noopener noreferrer\" target=\"_blank\">LINK</a> and I'll let you run wild with that.</p>\n<p>My blog is about the optimization techniques I used boost my engine speed up so much. Let's take a look at some of biggest points.</p>\n<p><a href=\"https://github.com/jackmead515/blog/blob/master/plugins/rust-wasm-sat/src/lib.rs\" rel=\"noopener noreferrer\" target=\"_blank\">Rust WASM Physics Engine Source Code</a></p>\n<h2 id=\"references\">References</h2>\n<p>This is one of the more obvious optimization techniques. Pass your data around as a reference until you\nactually need to mutate or get the data in that reference. below is the Javascript form of the dot product function vs the Rust version.</p>\n<pre><code class=\"javascript language-javascript\">// javascript\n\nfunction dot(v1, v2) {\n  return v1[0]*v2[0] + v1[1]*v2[1];\n}\n</code></pre>\n<pre><code class=\"rust language-rust\">// rust\n\npub fn dot(v1: &amp;[f32; 2], v2: &amp;[f32; 2]) -&gt; f32 {\n  let n1 = v1[0] * v2[0];\n  let n2 = v1[1] * v2[1];\n  return n1 + n2;\n}\n</code></pre>\n<p>Now, okay. I'll be fair here. The V8 Javascript engine will probably compile down this javascript to use references automatically in this function. It's not that dumb. But, at least in rust, we can explicitly declare the dot product function to demand the use of references.</p>\n<h2 id=\"typenotation\">Type Notation</h2>\n<p>Again, another obvious technique. But, it's worth pointing out that programming languages that declare the type for which the variable is of is always faster than those that don't. The compiler already knows how to create the memory for that specific variable and doesn't waste time on having to figure it out.</p>\n<pre><code class=\"javascript language-javascript\">// javascript\n\nfunction dot(v1, v2)\n</code></pre>\n<pre><code class=\"rust language-rust\">// rust\n\nfn dot(v1: &amp;[f32; 2], v2: &amp;[f32; 2])\n</code></pre>\n<p>Here, Rust is like, \"Alright, my dude. Your passing references to arrays of length two containing two valid 32 bit floats. Right on, brotha\".</p>\n<p>While Javascript is like, \"Umâ€¦ ahh.. your referencing an index.. so uhâ€¦ I guess your an array? Oh wait, you could be an object I guess. Oh wait, let me check, do I need to copy the values? Crap. Your multiplying the indexes together. Must be a number. Oh crap, I guess it could be a function that needs executingâ€¦\"</p>\n<p>You see the difference? Again, the V8 engine is pretty smart. But why rely on something else when we know the best optimization techniques?</p>\n<h2 id=\"threading\">Threading</h2>\n<p>Okay this is so cool. We can now multi-thread in the web. Whattt??? Yeah like straight up multithreading.\nNo, I'm not talking about web workers or some other bologna. Unfortunately, Rust WASM doesn't yet have support for multithreading so I can't really talk on this topic much. But look into it in the meantime! I'll have my eyes peeled for itâ€¦ ðŸ‘€</p>\n<h2 id=\"copyingandcloning\">Copying and Cloning</h2>\n<p>This is where we start to see major optimization improvements. In Javascript, you can't really decide when a value is just a reference or if it's entire contents are copied. In Rust / WASM, we do. Let's take a look at where this concept really sees performance.</p>\n<p>In my <a href=\"https://github.com/jackmead515/blog/blob/master/plugins/rust-wasm-sat/src/lib.rs#L165\" rel=\"noopener noreferrer\" target=\"_blank\">Rust engine loop</a>, we basically have this:</p>\n<pre><code class=\"rust language-rust\">for rect1 in rects {\n  for rect2 in rects {\n    // do stuff\n  }\n}\n</code></pre>\n<p>O(n^2) algorithm and all that junk. If I had multithreading, I could process the second loop in parallelâ€¦ but I don't have that yet. Soon! But, in Rust, this for loop gets a little trick since we are looping over the same array twice.</p>\n<p>In Rust, you can only reference a variable in one way at a time. Those ways are either by reference or mutable reference. So what I did was this:</p>\n<pre><code class=\"rust language-rust\">for rect1.clone() in rects {\n  for rect2.clone() in rects {\n    // done the stuffss\n  }\n}\n</code></pre>\n<p>But, as any programmer might see, I am literally copying every single rectangle every single loop. If I have 200 rectangles, that's (200 * 200) = 40000 copies every engine loop!!! Not good at all. When running the engine on this technique, the Rust engine performed around 15 FPS <strong>WORSE</strong> then Javascript!!</p>\n<p>So, to solve this?</p>\n<pre><code class=\"rust language-rust\">for rect1.clone() in rects {\n  for rect2.as_mut_ref() in rects {\n    // do siffss\n  }\n}\n</code></pre>\n<p>There. I just reduced the amount of copies by 39800. Boom. And I clearly did something right. Because after this, my Rust engine went from -15 FPS to +20 FPS!! That's a 35 FPS boost! Friggen nutts! As a general rule of thumb, it's always benefical to reduce the amount of times you copy or clone your data.\nCopying data is expensive.</p>\n<h2 id=\"arrayinitialization\">Array Initialization</h2>\n<p>The final technique I tried was array initialization with length. In both engines, the <code>tick()</code> function\nallows an update array to be passed into it. The array will be populated by the corresponding engine with the next state of the engine. Why do I do it like this?</p>\n<p>Well, in WASM, you cannot exchange memory with the host (javascript) unless it is a number. So returning something from WASM can be a pain. If I had to do this, this means I'd have to create a javascript bound array, clone every single rectangle into it, then return it. Every single engine loop? That can get expensive real fast. </p>\n<p>So, when I do is just pass a preinitialized array from Javascript to WASM and set the modified cloned value to the index in which it should be. Kind of like how you read into a bufferâ€¦</p>\n<pre><code class=\"rust language-rust\">let mut buffer: [u8; 5] = [0; 5];\nread(buffer);\n// buffer should be populated\n</code></pre>\n<p>In theory this should work, but I didn't really see much of a performance gain? I don't know. Not sure yet.</p>\n<h2 id=\"anyways\">Anywaysâ€¦</h2>\n<p>Thanks for reading. Hope you learned something from this. If you didn't, that's okay too. But now you get to play with a cool physics simulator ðŸ˜„</p>\n<p>Try out the WASM toggle, click Restart, and see the FPS performance gains. Peace.</p>\n<iframe id=\"sat-tester\" width=\"100%\" height=\"600\" src=\"https://www.speblog.org/plugin/sat-tester\">\n</iframe>"
}