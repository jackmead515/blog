{
  "head": {
    "title": "Building an AI for Weather Predicitions",
    "subtitle": "Building a time series forecasting AI with Keras for the weather",
    "date": 1574013600,
    "link": "building-lstm-neural-network-in-keras-for-weather-data",
    "description": "Building a LSTM neural network in keras has never been eaiser than before. Explore how to use the AI to predict the weather.",
    "image": "image/generic/ai.jpg",
    "tags": [
      "python", "ai", "deep", "machine", "learning", "numpy", "keras", "neural", "networks", "sklearn", "lstm", "pandas", "matplotlib", "programming"
    ]
  },
  "contents": [
    {
      "type": "p",
      "contents": "Finally it's time to build our network. In this blog, we will explore different parameters to fine tune an AI to predict the weather. This blog is broken into two other blogs, links are listed below as well."
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://mesonet.agron.iastate.edu/request/download.phtml"
      },
      "contents": "Iowa Environmental Mesonet (ISU)"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://github.com/jackmead515/python_ai/tree/master/temperature-in-iowa"
      },
      "contents": "Github Repo"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "http://www.speblog.org/blog/parsing-formatting-weather-data-numpy-pandas-sklearn"
      },
      "contents": "Preparing the Data"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "http://www.speblog.org/blog/visualizing-weather-data-numpy-pandas-sklearn-matplotlib"
      },
      "contents": "Visualizing the Data"
    },
    {
      "type": "p",
      "contents": "Parsing and formatting our dataset can take a while, but building and running our neural network can also take a long time. Selecting the layers we need usually doesn't take long at all (if you understand your dataset and the underlying problem to start). What takes a much longer time is fine tuning all the parameters in your network."
    },
    {
      "type": "p",
      "contents": "Good thing is, we already know what kind of network we want to build. That is a LSTM, or a Long Short Term Memory network. For reference and further reading, you can learn the exactness of the layer by peeking at the links below."
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://www.youtube.com/watch?v=wY0dyFgNCgY&t=144s"
      },
      "contents": "Jeff Heaton Youtube Channel"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras/"
      },
      "contents": "Machine Learning Mastery"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://keras.io/layers/recurrent/#lstm"
      },
      "contents": "Keras LSTM Documentation"
    },
    {
      "type": "p",
      "contents": "Lets start off by first stacking together the layers of our network."
    },
    {
      "type": "code",
      "props": {
        "language": "python",
        "source": "from sklearn.metrics import mean_squared_error\nfrom keras import models\nfrom keras import layers\nfrom keras import optimizers\nfrom keras import losses\n\nFEATURES = 1\nWINDOW_SIZE = 24\nNODES = 32\nEPOCHS = 30\nBATCH_SIZE = 100\nOPTIMIZER = optimizers.Adam()\nLOSS = losses.mean_squared_error\n\nmodel = models.Sequential()\nmodel.add(layers.LSTM(NODES, input_shape=(WINDOW_SIZE, FEATURES)))\nmodel.add(layers.Dense(1))\nmodel.compile(optimizer=OPTIMIZER, loss=LOSS)\n\nhistory = model.fit(x_train, y_train, epochs=EPOCHS, batch_size=BATCH_SIZE)\n\nx_pred = model.predict(x_test)\nscore = np.sqrt(mean_squared_error(x_pred, y_test))\nprint('Score (RMSE): {}'.format(score))"
      }
    },
    {
      "type": "p",
      "contents": "It's very easy to throw together a network with little effort. We are choosing to use an LSTM layer for the main guts of this ai. Then we apply a Dense layer with 1 output. This layer will use linear activation to produce one output, our prediction! Then, we compile our model with a loss of mean_squared_error and the adam optimizer. Evaluating the model using it's predict() method on the test set, we can compare the x_pred to the y_test using the mean_squared_error() method from sklearn. This will tell us just how far off our measurements are from the actual value."
    },
    {
      "type": "p",
      "props": {
        "embed": true
      },
      "contents": "Now when I say 'tuning parameters', specifically what I am refering to is these specific parameters: <b>nodes, window_size, optimizer, loss, batch_size, and epochs</b>. Every single one of these parameters should be tuned to create the best network possible."
    },
    {
      "type": "p",
      "contents": "We will get back to these parameters in a little bit, but for now, let's have a little fun and just try and run the network over the year 2005. Remember, a WINDOW_SIZE of 1 means that it is roughly 1 hour in the past (we might get a better performing AI if we understand how and when the temperature predictably changes and change the window size accordingly). Below is 5 different rounds with different parameters. View the results of each one!"
    },
    {
      "type": "mini",
      "props": {
        "title": "Round 1",
        "expanded": false
      },
      "contents": [
        {
          "type": "code",
          "props": {
            "language": "bash",
            "source": "FEATURES = 1\nWINDOW_SIZE = 1\nNODES = 8\nEPOCHS = 100\nBATCH_SIZE = 500\nOPTIMIZER = optimizers.Adam()\nLOSS = losses.mean_squared_error\n\nEpoch 1/100\n8612/8612 [==============================] - 0s 39us/step - loss: 0.1648\nEpoch 2/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.1454\nEpoch 3/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.1294\nEpoch 4/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.1165\nEpoch 5/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.1057\n...\nEpoch 95/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.0022\nEpoch 96/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.0022\nEpoch 97/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.0022\nEpoch 98/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.0022\nEpoch 99/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.0022\nEpoch 100/100\n8612/8612 [==============================] - 0s 4us/step - loss: 0.0022\n\nTraining Time: 4.261866092681885 secs\nTesting Score (RMSE): 1.4618483781814575"
          }
        }
      ]
    },
    {
      "type": "mini",
      "props": {
        "title": "Round 2",
        "expanded": false
      },
      "contents": [
        {
          "type": "code",
          "props": {
            "language": "bash",
            "source": "FEATURES = 1\nWINDOW_SIZE = 12\nNODES = 8\nEPOCHS = 100\nBATCH_SIZE = 500\nOPTIMIZER = optimizers.Adam()\nLOSS = losses.mean_squared_error\n\nEpoch 1/100\n8601/8601 [==============================] - 1s 61us/step - loss: 0.2035\nEpoch 2/100\n8601/8601 [==============================] - 0s 16us/step - loss: 0.1393\nEpoch 3/100\n8601/8601 [==============================] - 0s 17us/step - loss: 0.0946\nEpoch 4/100\n8601/8601 [==============================] - 0s 22us/step - loss: 0.0644\nEpoch 5/100\n8601/8601 [==============================] - 0s 17us/step - loss: 0.0443\n...\nEpoch 95/100\n8601/8601 [==============================] - 0s 15us/step - loss: 0.0017\nEpoch 96/100\n8601/8601 [==============================] - 0s 15us/step - loss: 0.0017\nEpoch 97/100\n8601/8601 [==============================] - 0s 15us/step - loss: 0.0017\nEpoch 98/100\n8601/8601 [==============================] - 0s 15us/step - loss: 0.0017\nEpoch 99/100\n8601/8601 [==============================] - 0s 15us/step - loss: 0.0017\nEpoch 100/100\n8601/8601 [==============================] - 0s 15us/step - loss: 0.0017\nTraining Time: 14.28614592552185 secs\nTesting Score (RMSE): 1.3082751035690308"
          }
        }
      ]
    },
    {
      "type": "mini",
      "props": {
        "title": "Round 3",
        "expanded": false
      },
      "contents": [
        {
          "type": "code",
          "props": {
            "language": "bash",
            "source": "FEATURES = 1\nWINDOW_SIZE = 24\nNODES = 16\nEPOCHS = 100\nBATCH_SIZE = 500\nOPTIMIZER = optimizers.Adam()\nLOSS = losses.mean_squared_error\n\nEpoch 1/100\n8589/8589 [==============================] - 1s 75us/step - loss: 0.1581\nEpoch 2/100\n8589/8589 [==============================] - 0s 39us/step - loss: 0.0730\nEpoch 3/100\n8589/8589 [==============================] - 0s 42us/step - loss: 0.0409\nEpoch 4/100\n8589/8589 [==============================] - 0s 40us/step - loss: 0.0251\nEpoch 5/100\n8589/8589 [==============================] - 0s 40us/step - loss: 0.0197\n...\nEpoch 95/100\n8589/8589 [==============================] - 0s 40us/step - loss: 0.0015\nEpoch 96/100\n8589/8589 [==============================] - 0s 40us/step - loss: 0.0014\nEpoch 97/100\n8589/8589 [==============================] - 0s 42us/step - loss: 0.0014\nEpoch 98/100\n8589/8589 [==============================] - 0s 41us/step - loss: 0.0014\nEpoch 99/100\n8589/8589 [==============================] - 0s 40us/step - loss: 0.0014\nEpoch 100/100\n8589/8589 [==============================] - 0s 41us/step - loss: 0.0014\nTraining Time: 35.53422498703003 secs\nTesting Score (RMSE): 1.2732785940170288"
          }
        }
      ]
    },
    {
      "type": "p",
      "contents": "More to come... Stay tuned..."
    }
  ]
}