{
  "head": {
    "title": "Elastic Collision",
    "subtitle": "Resolving collision between two polygons",
    "date": 1573322400,
    "link": "elastic-collision",
    "description": "Collisions between two objects need to properly resolve themselves according to their mass, speed, and direction of travel. Find out about how the algorithm works.",
    "image": "image/generic/universe.jpg",
    "tags": [
      "collision", "simulation", "math", "algorithm", "seperate", "axis", "theorem", "detection", "resolution",
      "gravity", "momentum", "javascript", "polygon", "programming"
    ]
  },
  "contents": [
    {
      "type": "p",
      "contents": "Elastic collision is very basic if you understand the underlying physics. This basic algorithm takes into account two objects mass and velocity to redirect each object accordingly. If we didn't take mass into account, objects would just smash into eachother and continue travelling in there respective directions! Not very realistic..."
    },
    {
      "type": "p",
      "contents": "Firstly, for extra reading reference, explore the links below. The wiki articles are jammed pack full of maths. While the OneLoneConder video is a very descriptive implementation of this. (Shout out to Mr. Coder. His video is very clear, concise, and easy to follow along)"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://www.youtube.com/watch?v=LPzyNOHY3A4"
      },
      "contents": "OneLoneCoder Circle-Circle Collision"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://en.wikipedia.org/wiki/Elastic_collision"
      },
      "contents": "Elastic Collision Wiki"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://en.wikipedia.org/wiki/Normal_(geometry)"
      },
      "contents": "Normal Line"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://en.wikipedia.org/wiki/Tangent"
      },
      "contents": "Tangent Line"
    },
    {
      "type": "a",
      "props": {
        "target": "tab",
        "href": "https://en.wikipedia.org/wiki/Dot_product"
      },
      "contents": "Dot Product"
    },
    {
      "type": "p",
      "contents": "But without further ado, we can get started. For reference and convience, the full source code is below."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "function elasticCollision(obj1, obj2, damping) {\n\tlet dx = obj2.x - obj1.x;\n\tlet dy = obj2.y - obj1.y;\n\tlet dr = Math.sqrt(dx * dx + dy * dy);\n\n\tlet nx = dx / dr;\n\tlet ny = dy / dr;\n\n\tlet tx = -ny;\n\tlet ty = nx;\n\n\tlet dpt1 = obj1.vx * tx + obj1.vy * ty;\n\tlet dpt2 = obj2.vx * tx + obj2.vy * ty;\n\n\tlet dpn1 = obj1.vx * nx + obj1.vy * ny;\n\tlet dpn2 = obj2.vx * nx + obj2.vy * ny;\n\n\tlet m1 = (dpn1 * (obj1.mass - obj2.mass) + 2.0 * obj2.mass * dpn2) / (obj1.mass + obj2.mass);\n\tlet m2 = (dpn2 * (obj2.mass - obj1.mass) + 2.0 * obj1.mass * dpn1) / (obj1.mass + obj2.mass);\n\n\tobj1.vx = (tx * dpt1 + nx * m1) * damping;\n\tobj1.vy = (ty * dpt1 + ny * m1) * damping;\n\n\tobj2.vx = (tx * dpt2 + nx * m2) * damping;\n\tobj2.vy = (ty * dpt2 + ny * m2) * damping;\n}"
      }
    },
    {
      "type": "p",
      "contents": "Elastic collision makes sense, but it can be challenging when first learning it. So I will walk line by line and explain exactly what is happening and the math behind it."
    },
    {
      "type": "p",
      "contents": "To start off, the first thing to do is get the distance between the two objects."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "let dx = obj2.x - obj1.x;\nlet dy = obj2.y - obj1.y;\nlet dr = Math.sqrt(dx * dx + dy * dy);"
      }
    },
    {
      "type": "p",
      "props": {
        "embed": true
      },
      "contents": "If you can recognize this algorithm, you've got it! It's Pythagoras. Very simply: <b>the square root of x squared plus y squared</b>. However, <b>dx</b> and <b>dy</b> describe the edges in the x and y axises (this is why we subtract the points). Variable <b>dr</b> now describes the hypotenuse edge, or, the direct line between obj1's position and obj2's."
    },
    {
      "type": "p",
      "contents": "Now, with this information, the next step is to compute a line tangent or the normal to this edge."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "let nx = dx / dr;\nlet ny = dy / dr;\n\nlet tx = -ny;\nlet ty = nx;"
      }
    },
    {
      "type": "p",
      "props": {
        "embed": true
      },
      "contents": "<b>nx</b> and <b>ny</b> describe the normalization of the hypotenuse edge. Normalizing is where we basically take the magnitude of the vector in the x and y direction. These magnitudes will be numbers between 0 and 1."
    }, 
    {
      "type": "p",
      "props": {
        "embed": true
      },
      "contents": "<b>tx</b> and <b>ty</b> describe the normal to the edge. Meaning, this is a line perpendicular (at 90 degrees) to the hypotenuse edge."
    },
    {
      "type": "p",
      "contents": "Alright, take a breath. If any of this was difficult for you, it's about to get a bit more complicated. But not to worry, we are taking it step by step! Refer to the resources I listed at the top to go over some of the mathematical terms I went over. Don't worry, you'll get it."
    },
    {
      "type": "p",
      "contents": "For the next magic trick, we are going to compute the dot product with regard to the velocity vectors of each object using the normal and the edge. Let's see the code."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "// Dot product using the normal edge\nlet dpt1 = obj1.vx * tx + obj1.vy * ty;\nlet dpt2 = obj2.vx * tx + obj2.vy * ty;\n\n// Dot product using the normalized edge (hypotenuse)\nlet dpn1 = obj1.vx * nx + obj1.vy * ny;\nlet dpn2 = obj2.vx * nx + obj2.vy * ny;"
      }
    },
    {
      "type": "p",
      "props": {
        "embed": true
      },
      "contents": "Very simply, the dot product is going to be the magnitude of the overall projection. When we compute the dot product with respect to the hypotenuse, we are actually saying <b>How much velocity is in the 'hypotenuse' direction</b>. And same thing with the normal line. We are actually saying <b>How much velocity is in the 'normal' direction</b>."
    },
    {
      "type": "p",
      "contents": "Since velocity is a vector, and we have two objects, we have essentially created two new vector describing the direction of travel in the 'normal' and 'hypotenuse' directions."
    },
    {
      "type": "p",
      "contents": "Now, we could stop here. We really have completely calculated a perfect elastic collision if each object has the same mass. We could update the objects velocities doing the following and have a wicked cool physics simulation."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "obj1.vx = tx * dpt1 + nx * dpn1;\nobj1.vy = ty * dpt1 + ny * dpn1;\n\nobj2.vx = tx * dpt2 + nx * dpn2;\nobj2.vy = ty * dpt2 + ny * dpn2;"
      }
    },
    {
      "type": "p",
      "contents": "Sad thing is, that if obj1 is a truck, and obj2 is a mouse, the truck wouldn't completely destory the mouse. They would just kind of sadly collide and then travel more slowly in the direction of the truck... Obviously we want more from our game. So let's consider mass in the equation."
    },
    {
      "type": "p",
      "contents": "Now that we have the direction of travel, we need to know just how fast the objects should travel in there respective directions. Using the velocity and mass of each object, we can calculate for momentum. Again, code please."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "// Momentum for obj1 which respect to obj2\nlet m1 = (dpn1 * (obj1.mass - obj2.mass) + 2.0 * obj2.mass * dpn2) / (obj1.mass + obj2.mass);\n\n// Momentum for obj2 with repsect to obj1\nlet m2 = (dpn2 * (obj2.mass - obj1.mass) + 2.0 * obj1.mass * dpn1) / (obj1.mass + obj2.mass);"
      }
    },
    {
      "type": "p",
      "contents": "Now, I won't begin to try to convince you that I understand the mathematics in full detail. I have throughly looked over the resources in the links above however, and, it seems as if the equations are straightforward to derive. We don't have to do that though because it's already been done! For now, we will take a leap of faith and trust that these algorithms are derived correctly. If you'd like to go and rederive them, I would highly respect that. Wizard hat for whoever does."
    },
    {
      "type": "p",
      "contents": "Now that we can consider the momentum, we can finally update the the velocity of each object by doing the following."
    },
    {
      "type": "code",
      "props": {
        "language": "javascript",
        "source": "obj1.vx = (tx * dpt1 + nx * m1) * damping;\nobj1.vy = (ty * dpt1 + ny * m1) * damping;\n\nobj2.vx = (tx * dpt2 + nx * m2) * damping;\nobj2.vy = (ty * dpt2 + ny * m2) * damping;"
      }
    },
    {
      "type": "p",
      "props": {
        "embed": true
      },
      "contents": "Finally, we have a working algorithm that describes perfect elastic collision. Or does it? It reality, objects absorb some of the energy. That's where this <b>damping</b> variable comes from. Modifying this value between 0 and 1 will produce some absorption, where 0 would be complete absorption and 1 would be completely elastic."
    },
    {
      "type": "p",
      "contents": "You can experiment in this collision simulation below! Enjoy! Please comment with any suggestions, comments, or angry messages because you can't figure it out. I'd be happy to help."
    },
    {
      "type": "plugin",
      "props": {
        "source": "plugin/sat-tester",
        "id": "sat-tester",
        "width": "100%",
        "height": "400"
      }
    }
  ]
}